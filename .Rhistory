}
PostProcessing(header, NR, N5R, Male_Spawners_NR,Female_Spawners_NR,Rainbow_Male_Spawners_NR,Rainbow_Female_Spawners_NR, Escapement_NR,
Female_Escapement_NR, N_Smolts_NR, N_NOS_NR, N_NOB_NR, N_HOS_NR, N_HOB_NR, N_SPAWNER_RECRUIT_NR,
N_Broodstock_NR, N_Extra_NR, N_SmoltsFromHatchery_NR,
RootDir)
####################################################################
# Generate plot for coefficient of variation vs number of MC iterations
if (header$R > 1) {
if (header$K==1) {mar = 2} else {mar = 3}
r.range=2:200
escapement_Mean = mean(apply(Escapement_NR[,header$Tr-1,,],mar,sum)) #to correct error, Pete changed apply argument 2 to 2 (from 3)
escapement_SD = sd(apply(Escapement_NR[,header$Tr-1,,],mar,sum))
escapement_se_by_r = escapement_SD/sqrt(r.range)
escapement_COV_by_r = escapement_se_by_r/ escapement_Mean
OnePlus_Cand_mean = mean(apply(Candidate_Smolt_NR[,header$Tr-1,,],mar,sum))
OnePlus_Cand_SD = sd(apply(Candidate_Smolt_NR[,header$Tr-1,,],mar,sum))
OnePlus_Cand_se_by_r= OnePlus_Cand_SD/sqrt(r.range)
OnePlus_Cand_COV_by_r= OnePlus_Cand_se_by_r /  OnePlus_Cand_mean
plot(r.range, escapement_COV_by_r, type="l",
main="Coefficient of Variation for Total Escapement and
Total OnePlus, by Number of MC Iterations" ,
xlab= "Number of MC Iterations",
ylab="Coefficient of Variation",
ylim=c(0, 1))
lines(r.range, OnePlus_Cand_COV_by_r, lt=2)
legend("topright", c("Escapement", "Smolts (Pre-Dam Passage)"), lt=c(1,2))
}
print("Done.")
}
# run once from the current directory
Directories <- c(".")
for(ii in 1:length(Directories)) {
RootDir = file.path(getwd(), Directories[ii])
Watershed(RootDir, BATCH)
}
# run from a nested series of directories
#Directories <- c("WatershedExample1", "WatershedExample2", "WatershedExample3")
#SubDirectories <- c("Test1", "Test2", "Test3")
#for(ii in 1:length(Directories)) {
#  for(jj in 1:length(SubDirectories)) {
#    RootDir = file.path(getwd(), Directories[ii], SubDirectories[jj])
#    Watershed(RootDir, BATCH)
#  }
#}
# 1--------------------SPECIFY SCENARIO-----------------------#
scenario_name <- "CC" # your scenario name here
years <- 100
runs <- 100
population <- "CC" # CC or UGR
# Initial values
seed_fry <- 100000
seed_hatchery_smolt <- 100000
# Stop supplementation in year
stop_sup <- 60 # set to YEARS if ON, set to ZERO if OFF
# 2---------------READ IN THE INPUT FILE----------------------#
#model inputs
input <- read.csv(file.choose(), stringsAsFactors = FALSE)
# 3---------------CALL THE MODEL-------------------------------#
source("UGRLifeCycle_Run.R")
setwd("~/Documents/NicksSoftware/UGR_LCM_Weber")
# 1--------------------SPECIFY SCENARIO-----------------------#
scenario_name <- "CC" # your scenario name here
years <- 100
runs <- 100
population <- "CC" # CC or UGR
# Initial values
seed_fry <- 100000
seed_hatchery_smolt <- 100000
# Stop supplementation in year
stop_sup <- 60 # set to YEARS if ON, set to ZERO if OFF
# 2---------------READ IN THE INPUT FILE----------------------#
#model inputs
input <- read.csv(file.choose(), stringsAsFactors = FALSE)
# 3---------------CALL THE MODEL-------------------------------#
source("UGRLifeCycle_Run.R")
# 3---------------CALL THE MODEL-------------------------------#
source("UGRLifeCycle_Run.R")
# 4----------------CALL SUMMARY GRAPHICS-----------------------#
source("UGRLifeCycle_Plot.R", print.eval=TRUE)
# 1--------------------SPECIFY SCENARIO-----------------------#
scenario_name <- "CC" # your scenario name here
years <- 100
runs <- 100
population <- "CC" # CC or UGR
# Initial values
seed_fry <- 100000
seed_hatchery_smolt <- 100000
# Stop supplementation in year
stop_sup <- 60 # set to YEARS if ON, set to ZERO if OFF
# 2---------------READ IN THE INPUT FILE----------------------#
#model inputs
input <- read.csv(file.choose(), stringsAsFactors = FALSE)
# 3---------------CALL THE MODEL-------------------------------#
source("UGRLifeCycle_Run.R")
# 4----------------CALL SUMMARY GRAPHICS-----------------------#
source("UGRLifeCycle_Plot.R", print.eval=TRUE)
# 1--------------------SPECIFY SCENARIO-----------------------#
scenario_name <- "CC" # your scenario name here
years <- 100
runs <- 100
population <- "CC" # CC or UGR
# Initial values
seed_fry <- 100000
seed_hatchery_smolt <- 100000
# Stop supplementation in year
stop_sup <- 60 # set to YEARS if ON, set to ZERO if OFF
# 2---------------READ IN THE INPUT FILE----------------------#
#model inputs
input <- read.csv(file.choose(), stringsAsFactors = FALSE)
library(tidyverse) # for data manipulation and graphics
library(VGAM) # postive only normal distribution function
#Supplementation goal based on population as total brood retention
if (population == "CC") {
brood_goal = 102
} else {
brood_goal = 170
}
View(input)
for (i in 1:nrow(input)) {
assign(paste("p_",input$Stage_Transition[i], sep=""), c(input$Productivity[i], input$Productivity_SD[i],
input$Capacity[i], input$Capacity_SD[i],
input$Transition[i], input$Transition_SD[i],
input$Natural_Prod_Scaler[i], input$Hatchery_Prod_Scaler[i],
input$Natural_Cap_Scaler[i], input$Hatchery_Cap_Scaler[i]))
}
type(brood_goal)
type(brood_goal)
class(brood_goal)
class(p_Egg_Fry)
str(p_Egg_Fry)
typeof(p_Egg_Fry)
p_Egg_Fry
p_Egg_Fry[5]
p_Egg_Fry[1:3]
my_array <- c(1, 2, 3, 4, 5)
my_array
my_array[1:2]
my_array[1:3]
my_array[3:3]
my_array[:3]
my_array[1:3]
for i in my_array {
i
}
for (i in my_array) {
i
}
for (i in 1:my_array) {
i
}
for (i in my_array) {
my_array[i]
}
for (i in 1:my_array) {
my_array[i]
}
for (i in 1:max(my_array)) {
my_array[i]
}
for (i in 1:max(my_array)) {
i
}
for (i in 1:max(my_array)) {
i + 2
}
for (i in my_array) {
i + 2
}
for (i in my_array) {
print(i + 2)
}
i = 1
while (i < 50) {
print("i is fucking ",i)
i <- i + 1
}
i = 1
while (i < 50) {
print(paste("i is fucking ",i))
i <- i + 1
}
i = 1
while (i < 50) {
print(paste("i is fucking ", i, sep=""))
i <- i + 1
}
test <- 20
if (test < 50) {
print("Yup it's less")
else {
print("It's fucking more")
}
}
test <- 20
if (test < 50) {
print("Yup it's less")
} else {
print("It's fucking more")
}
test <- 510
if (test < 50) {
print("Yup it's less")
} else {
print("It's fucking more")
}
beta_params = estBetaParams(0.5, 0.2)
# beta parameter estimation
estBetaParams <- function(mu, var) {
alpha <- ((1 - mu) / var - 1 / mu) * mu ^ 2
beta <- alpha * (1 / mu - 1)
return(params = list(alpha = alpha, beta = beta))
}
beta_params = estBetaParams(0.5, 0.2)
beta_params
beta_params$alpha
test = list(1, 3, 4)
test
test[1]
test[2]
test = list((1, 3, 4), (5,6,7))
# 1--------------------SPECIFY SCENARIO-----------------------#
scenario_name <- "CC" # Your scenario name here
years <- 100
runs <- 100
population <- "CC" # CC or UGR
# Initial values
seed_fry <- 100000
seed_hatchery_smolt <- 100000
# Stop supplementation in year stop_sup, set to ZERO to turn supplimentation OFF
stop_sup <- 60 # set to YEARS if ON, set to ZERO if OFF
# 2---------------READ IN THE INPUT FILE---------------------------#
#model inputs
input <- read.csv(file.choose(), stringsAsFactors = FALSE)
# 3---------------LOAD FUNCTIONS AND RUN THE MODEL-----------------#
source("UGRLifeCycle_Functions.R")
source("UGRLifeCycle_Run.R")
# 4----------------CALL SUMMARY AND GRAPHICS-----------------------#
source("UGRLifeCycle_Plot.R", print.eval=TRUE)
# 4----------------CALL SUMMARY AND GRAPHICS-----------------------#
source("UGRLifeCycle_Plot.R", print.eval=TRUE)
while (i < 50) {
print(paste("fucking",i))
}
i <- 0
while (i < 50) {
i <- i + 1
print(paste("fucking",i))
}
i <- 0
while (i < 50^100000000) {
i <- i + 1
print(paste("fucking",i))
}
# 1--------------------SPECIFY SCENARIO-----------------------#
scenario_name <- "CC" # Your scenario name here
years <- 100
runs <- 100
population <- "CC" # CC or UGR
# Initial values
seed_fry <- 100000
seed_hatchery_smolt <- 100000
# Stop supplementation in year stop_sup, set to ZERO to turn supplimentation OFF
stop_sup <- 60 # set to YEARS if ON, set to ZERO if OFF
# 2---------------READ IN THE INPUT FILE---------------------------#
#model inputs
input <- read.csv(file.choose(), stringsAsFactors = FALSE)
# 3---------------LOAD FUNCTIONS AND RUN THE MODEL-----------------#
source("UGRLifeCycle_Functions.R")
source("UGRLifeCycle_Run.R")
# 4----------------CALL SUMMARY AND GRAPHICS-----------------------#
source("UGRLifeCycle_Plot.R", print.eval=TRUE)
# 5------------WRITE OUTPUT TO WORKING DIRECTORY----------------#
# final dataframe with all raw simulation values
write.csv(final, file=paste(getwd(),"/",scenario_name,"_final.csv", sep=""))
# summary dataframe with summarized values
write.csv(summary, file=paste(getwd(),"/",scenario_name,"_summary.csv", sep=""))
est_beta_params <- function(mu, var) {
alpha <- ((1 - mu) / var - 1 / mu) * mu ^ 2
beta <- alpha * (1 / mu - 1)
return(params = list(alpha = alpha, beta = beta))
}
trans1_mean = 0.7
trans1_sd = 0.5
# Calculate random beta probability for each choice
beta_shapes <- est_beta_params(trans1_mean, trans1_sd^2)
tran_prob1 <-  rbeta(1, beta_shapes$alpha, beta_shapes$beta)
tran_prob2 <- 1 - tran_prob1
tran_prob1 <-  rbeta(1, beta_shapes$alpha, beta_shapes$beta)
# Calculate random beta probability for each choice
beta_shapes <- est_beta_params(trans1_mean, trans1_sd^2)
tran_prob1 <-  rbeta(1, beta_shapes$alpha, beta_shapes$beta)
tran_prob2 <- 1 - tran_prob1
trans1_mean = 0.7
trans1_sd = 0.3
# Calculate random beta probability for each choice
beta_shapes <- est_beta_params(trans1_mean, trans1_sd^2)
tran_prob1 <-  rbeta(1, beta_shapes$alpha, beta_shapes$beta)
tran_prob2 <- 1 - tran_prob1
trans1_mean = 0.7
trans1_sd = 0.5
# Calculate random beta probability for each choice
beta_shapes <- est_beta_params(trans1_mean, trans1_sd^2)
tran_prob1 <-  rbeta(1, beta_shapes$alpha, beta_shapes$beta)
tran_prob2 <- 1 - tran_prob1
# Calculate random beta probability for each choice
beta_shapes <- est_beta_params(trans1_mean, trans1_sd^2)
tran_prob1 <-  rbeta(1, beta_shapes$alpha, beta_shapes$beta)
tran_prob2 <- 1 - tran_prob1
trans1_mean = 0.7
trans1_sd = 0.5
trans1_mean = 0.7
trans1_sd = 0.3
# Calculate random beta probability for each choice
beta_shapes <- est_beta_params(trans1_mean, trans1_sd^2)
tran_prob1 <-  rbeta(1, beta_shapes$alpha, beta_shapes$beta)
tran_prob2 <- 1 - tran_prob1
trans1_mean = 0.9
trans1_sd = 0.5
# Calculate random beta probability for each choice
beta_shapes <- est_beta_params(trans1_mean, trans1_sd^2)
tran_prob1 <-  rbeta(1, beta_shapes$alpha, beta_shapes$beta)
tran_prob2 <- 1 - tran_prob1
trans1_mean = 0.9
trans1_sd = 0.4
# Calculate random beta probability for each choice
beta_shapes <- est_beta_params(trans1_mean, trans1_sd^2)
tran_prob1 <-  rbeta(1, beta_shapes$alpha, beta_shapes$beta)
tran_prob2 <- 1 - tran_prob1
trans1_sd^2
# Calculate random beta probability for each choice
beta_shapes <- est_beta_params(trans1_mean, trans1_sd^2)
tran_prob1 <-  rbeta(1, beta_shapes$alpha, beta_shapes$beta)
tran_prob2 <- 1 - tran_prob1
trans1_mean = 0.9
trans1_sd = 0.2
trans1_sd^2
# Calculate random beta probability for each choice
beta_shapes <- est_beta_params(trans1_mean, trans1_sd^2)
tran_prob1 <-  rbeta(1, beta_shapes$alpha, beta_shapes$beta)
tran_prob2 <- 1 - tran_prob1
trans1_mean = 0.9
trans1_sd = 0.8
trans1_sd^2
# Calculate random beta probability for each choice
beta_shapes <- est_beta_params(trans1_mean, trans1_sd^2)
tran_prob1 <-  rbeta(1, beta_shapes$alpha, beta_shapes$beta)
tran_prob2 <- 1 - tran_prob1
trans1_mean = 0.9
trans1_sd = 0.8
trans1_sd^2
my_parms <- c(1, 1, 1, 1, 0.75, 0.1)
my_parms[5]
est_beta_params <- function(mu, var) {
alpha <- ((1 - mu) / var - 1 / mu) * mu ^ 2
beta <- alpha * (1 / mu - 1)
return(params = list(alpha = alpha, beta = beta))
}
my_parms <- c(1, 1, 1, 1, 0.75, 0.1)
start_pop <- 100
end1_pop <- 0
end2_pop <- 0
# Calculate random beta probability for each choice
move_choice <- function(choice1_parms) {
beta_shapes <- est_beta_params(choice1_parms[5], choice1_parms[6]^2)
prob1 <- rbeta(1, beta_shapes$alpha, beta_shapes$beta)
prob2 <- 1 - prob1
return(choice_probs = list(prob1 = prob1, prob2 = prob2))
}
move_choice(my_parms)
# Calculate random beta probability for each choice
move_choice <- function(choice1_parms) {
beta_shapes <- est_beta_params(choice1_parms[5], choice1_parms[6]^2)
prob1 <- rbeta(1, beta_shapes$alpha, beta_shapes$beta)
prob2 <- 1 - prob1
return(choice_probs <- list(prob1 <- prob1, prob2 <- prob2))
}
choice_probs <- move_choice(my_parms)
choice_probs[1]
choice_probs[2]
choice_probs$probs1
end1_pop <- start_pop * choice_probs$probs1
end2_pop <- start_pop * choice_probs$probs2
end1_pop <- start_pop * choice_probs[1]
end2_pop <- start_pop * choice_probs[2]
choice_probs <- move_choice(my_parms)
choice_probs[1]
choice_probs[2]
choice_probs[1]
choice_probs[2]
# Test
end1_pop <- start_pop * choice_probs[1]
start_pop * choice_probs[1]
choice_probs[1]
# Calculate random beta probability for each choice
move_choice <- function(choice1_parms) {
beta_shapes <- est_beta_params(choice1_parms[5], choice1_parms[6]^2)
prob1 <- rbeta(1, beta_shapes$alpha, beta_shapes$beta)
prob2 <- 1 - prob1
return(choice_probs <- list(prob1 = prob1, prob2 = prob2))
}
choice_probs <- move_choice(my_parms)
# Test
end1_pop <- start_pop * choice_probs$prob1
end2_pop <- start_pop * choice_probs$prob2
# Calculate random beta probability for each choice
move_choice <- function(choice1_parms) {
beta_shapes <- est_beta_params(choice1_parms[5], choice1_parms[6]^2)
prob1 <- rbeta(1, beta_shapes$alpha, beta_shapes$beta)
prob2 <- 1 - prob1
choice_probs <- list(prob1 = prob1, prob2 = prob2)
return(choice_probs)
}
choice_probs <- move_choice(my_parms)
# Test
end1_pop <- start_pop * choice_probs$prob1
end2_pop <- start_pop * choice_probs$prob2
choice_probs <- move_choice(my_parms)
# Test
end1_pop <- start_pop * choice_probs$prob1
end2_pop <- start_pop * choice_probs$prob2
choice_probs <- move_choice(my_parms)
# Test
end1_pop <- start_pop * choice_probs$prob1
end2_pop <- start_pop * choice_probs$prob2
choice_probs <- move_choice(my_parms)
# Test
end1_pop <- start_pop * choice_probs$prob1
end2_pop <- start_pop * choice_probs$prob2
choice_probs <- move_choice(my_parms)
# Test
end1_pop <- start_pop * choice_probs$prob1
end2_pop <- start_pop * choice_probs$prob2
choice_probs <- move_choice(my_parms)
# Test
end1_pop <- start_pop * choice_probs$prob1
end2_pop <- start_pop * choice_probs$prob2
choice_probs <- move_choice(my_parms)
# Test
end1_pop <- start_pop * choice_probs$prob1
end2_pop <- start_pop * choice_probs$prob2
choice_probs <- move_choice(my_parms)
# Test
end1_pop <- start_pop * choice_probs$prob1
end2_pop <- start_pop * choice_probs$prob2
choice_probs <- move_choice(my_parms)
# Test
end1_pop <- start_pop * choice_probs$prob1
end2_pop <- start_pop * choice_probs$prob2
choice_probs <- move_choice(my_parms)
# Test
end1_pop <- start_pop * choice_probs$prob1
end2_pop <- start_pop * choice_probs$prob2
choice_probs <- move_choice(my_parms)
# Test
end1_pop <- start_pop * choice_probs$prob1
end2_pop <- start_pop * choice_probs$prob2
choice_probs <- move_choice(my_parms)
# Test
end1_pop <- start_pop * choice_probs$prob1
end2_pop <- start_pop * choice_probs$prob2
choice_probs <- move_choice(my_parms)
# Test
end1_pop <- start_pop * choice_probs$prob1
end2_pop <- start_pop * choice_probs$prob2
choice_probs <- move_choice(my_parms)
# Test
end1_pop <- start_pop * choice_probs$prob1
end2_pop <- start_pop * choice_probs$prob2
choice_probs <- move_choice(my_parms)
# Test
end1_pop <- start_pop * choice_probs$prob1
end2_pop <- start_pop * choice_probs$prob2
choice_probs <- move_choice(my_parms)
# Test
end1_pop <- start_pop * choice_probs$prob1
end2_pop <- start_pop * choice_probs$prob2
choice_probs <- move_choice(my_parms)
# Test
end1_pop <- start_pop * choice_probs$prob1
end2_pop <- start_pop * choice_probs$prob2
choice_probs <- move_choice(my_parms)
# Test
end1_pop <- start_pop * choice_probs$prob1
end2_pop <- start_pop * choice_probs$prob2
choice_probs <- move_choice(my_parms)
# Test
end1_pop <- start_pop * choice_probs$prob1
end2_pop <- start_pop * choice_probs$prob2
choice_probs <- move_choice(my_parms)
# Test
end1_pop <- start_pop * choice_probs$prob1
end2_pop <- start_pop * choice_probs$prob2
choice_probs <- move_choice(my_parms)
# Test
end1_pop <- start_pop * choice_probs$prob1
end2_pop <- start_pop * choice_probs$prob2
choice_probs <- move_choice(my_parms)
# Test
end1_pop <- start_pop * choice_probs$prob1
end2_pop <- start_pop * choice_probs$prob2
choice_probs <- move_choice(my_parms)
# Test
end1_pop <- start_pop * choice_probs$prob1
end2_pop <- start_pop * choice_probs$prob2
choice_probs <- move_choice(my_parms)
# Test
end1_pop <- start_pop * choice_probs$prob1
end2_pop <- start_pop * choice_probs$prob2
choice_probs <- move_choice(my_parms)
# Test
end1_pop <- start_pop * choice_probs$prob1
end2_pop <- start_pop * choice_probs$prob2
